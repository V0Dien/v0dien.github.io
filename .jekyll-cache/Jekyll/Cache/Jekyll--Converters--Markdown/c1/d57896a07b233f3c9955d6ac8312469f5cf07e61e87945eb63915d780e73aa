I".!<p>Một bài chia sẻ, tổng hợp kiến thức cá nhân giúp mình hoàn thành các thử thách truyền thông tin sử dụng giao thức USB sang PC/Laptop được capture thông qua Wireshark hoặc T-shark và lưu dưới tệp tin Pcap/Pcapng.</p>

<h2 id="0x01-các-định-dạng-truyền-dữ-liệu">0x01: Các định dạng truyền dữ liệu</h2>

<p><img src="/assets/img/blog/1_DangUSB.JPG" alt="IMG" /></p>

<p>Có 4 định dạng truyền dữ liệu thông qua USB đó là:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> --><td class="rouge-code"><pre>- Control Transfers (0x02)
- Interrupt Transfers (0x01)
- Isochronous Transfers (0x00)
- Bulk Transfers (0x03)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Với các mã hex tương ứng cho câu lệnh lọc gói tin trên Wireshark, ví dụ <code class="language-plaintext highlighter-rouge">usb.transfer_type == 0x01</code> sẽ giúp chúng ta lọc ra toàn bộ các gói tin được gửi đi dưới phương thức Interrupt.</p>

<p><img src="/assets/img/blog/2_VdInterrupt.JPG" alt="IMG" /></p>

<h3 id="control-transfers">Control Transfers</h3>

<p>Đây là dạng giao thức được sử dụng cho việc thiết lập USB và trạng thái của thiết bị cũng như endpoint.</p>

<h3 id="interrupt-transfers">Interrupt Transfers</h3>

<p>Dạng giao thức được dùng để truyền dữ liệu từ bàn phím, chuột đến máy tính</p>

<h3 id="isochronous-transfers">Isochronous Transfers</h3>

<p>Dạng giao thức được dùng để truyền tải âm thanh đến các thiết bị ngoại vi âm thanh như tai nghe, loa,…</p>

<h3 id="bulk-transfers">Bulk Transfers</h3>

<p>Dạng giao thức được dùng để truyền tải dữ liệu lớn như là một bức ảnh được gửi từ máy tính qua máy in hoặc từ máy quét sang máy tính.</p>

<h2 id="0x02-đọc-dữ-liệu-được-nhập-từ-bàn-phím">0x02: Đọc dữ liệu được nhập từ bàn phím</h2>

<h3 id="xác-định-và-cách-đọc-dữ-liệu">Xác định và cách đọc dữ liệu</h3>

<p>Vì dữ liệu truyền vào từ bàn phím thuộc <code class="language-plaintext highlighter-rouge">interrupt transfers</code> nên để xác định được các gói tin liên quan mình dùng lệnh <code class="language-plaintext highlighter-rouge">usb.transfer_type == 0x01</code> trong Wireshark để filter gói tin. Vì bàn phím là thiết bị có tốc độ thấp nên dữ liệu sẽ luôn ở dạng 8 bytes xx:xx:xx:xx:xx:xx:xx:xx.</p>

<p><img src="/assets/img/blog/3_dinhdangbytes.JPG" alt="IMG" /></p>

<p>Thông thường thông tin của thiết bị sẽ được ghi trong các gói tin <code class="language-plaintext highlighter-rouge">GET DESCRIPTOR Request/Response DEVICE</code> tuy nhiên những gói tin này nằm ngoài phạm vi của bài viết nên mình sẽ không đề cập đến mà chỉ tập trung vào cách lấy dữ liệu từ pcap/pcapng.</p>

<p>Trong hình trên ta thấy ở gói tin số 1 có thông tin <code class="language-plaintext highlighter-rouge">00:00:09:00:00:00:00:00</code>, với <code class="language-plaintext highlighter-rouge">09</code> tương ứng với chữ <code class="language-plaintext highlighter-rouge">f</code> trên bàn phím. Tại sao lại như vậy? Đó là do thống nhất giữa máy tính và bàn phím, thông tin về mã hex tương ứng với từng bàn phím, các bạn có thể tham khảo tại đây: <a href="https://usb.org/sites/default/files/documents/hut1_12v2.pdf">https://usb.org/sites/default/files/documents/hut1_12v2.pdf</a> trang 53.</p>

<p>Tuy nhiên chú ý thì gói tin số 10, lại có <code class="language-plaintext highlighter-rouge">02</code> đứng đầu, vậy nó khác gì so với gói tin 01 có bytes đầu là <code class="language-plaintext highlighter-rouge">00</code>?</p>

<p><img src="/assets/img/blog/3_dinhdangbytes2.JPG" alt="IMG" /></p>

<p>Đó là khi người dùng đè <code class="language-plaintext highlighter-rouge">shift</code> + <code class="language-plaintext highlighter-rouge">something</code>. Trong trường hợp trên <code class="language-plaintext highlighter-rouge">2F</code> tương ứng với dấu <code class="language-plaintext highlighter-rouge">[</code> nhưng vì đè shift đằng trước nên kí tự đúng sẽ là <code class="language-plaintext highlighter-rouge">{</code>.</p>

<p>Vậy tất cả các bàn phím đều giống nhau? Câu trả lời là <code class="language-plaintext highlighter-rouge">không</code>. Mỗi quốc gia sử dụng những ngôn ngữ, kiểu chữ khác nhau sẽ có những mã hex tương ứng với từng kí tự của ngôn ngữ đó. Ví dụ như crush 7 năm của mình là người rất thích, và là chuyên gia tiếng Nhật nên mình tìm hiểu thì ra được bảng này: <a href="http://hp.vector.co.jp/authors/VA003720/lpproj/others/kbdjpn.htm">http://hp.vector.co.jp/authors/VA003720/lpproj/others/kbdjpn.htm</a>. Đây là trang web so sánh sự khác, giống nhau của bàn phím tiếng Nhật với bàn phím theo chuẩn quốc tế mà chúng ta hay thường sử dụng.</p>

<p>Có bạn sẽ thắc mắc vậy bàn phím của Việt Nam thì sao? Mình xin trả lời việc chúng ta đánh máy bằng Telex hay VNI để ghi tiếng Việt có dấu là xử lý ở mức độ application, không liên quan đến việc input data từ bàn phím. Dù bạn gõ tiếng Việt nhưng nếu thử capture bằng Wireshark thì chắc chắn gói tin bạn nhận được vẫn sẽ theo dạng kí tự nhập vào. Ví dụ mình gõ VNI <code class="language-plaintext highlighter-rouge">chào</code> thì khi capture và xuất dữ liệu, kết quả chúng ta nhận được là <code class="language-plaintext highlighter-rouge">chao2</code>.</p>

<p>8 bytes dữ liệu này sẽ luôn xuất hiện dưới 1 trong 2 trường là: <code class="language-plaintext highlighter-rouge">Leftover Capture data</code> hoặc <code class="language-plaintext highlighter-rouge">HID Data</code> tại thông tin của mỗi gói tin; sự khác biệt này hiện tại mình chưa tìm ra nguyên nhân, nên khi xem xét một gói tin mình luôn làm theo flow và theo dõi data trong đó để xác định.</p>

<h3 id="xuất-kết-quả">Xuất kết quả</h3>

<p>Chúng ta không thể cứ đọc từng line và so sánh từng dòng code với từng mã hex trong bảng được. Vì vậy cách nhanh nhất là xuất bằng command line. Mình thường sử dụng <code class="language-plaintext highlighter-rouge">tshark</code> để xuất thông tin sau đó decode.</p>

<p>Câu lệnh <code class="language-plaintext highlighter-rouge">tshark</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre><span class="nv">$ </span>tshark <span class="nt">-r</span> ./usb.pcap <span class="nt">-Y</span> <span class="s1">'usb.capdata &amp;&amp; usb.data_len == 8'</span> <span class="nt">-T</span> fields <span class="nt">-e</span> usb.capdata | <span class="nb">sed</span> <span class="s1">'s/../:&amp;/g2'</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Ở một số phiên bản sẽ in sẵn dấu <code class="language-plaintext highlighter-rouge">:</code> cho từng bytes thì các bạn có thể xóa lệnh pipe sed.</p>

<p>Tiếp theo, mình decode những mã hex vừa được output.</p>

<p>EzPz.</p>

<p>Một số thử thách CTF liên quan đến vấn đề này các bạn có thể thử là:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> --><td class="rouge-code"><pre>- PicoCTF 2017_Just Keyp Trying

- IceCTF2016

- Bsidesf CTF_The Key.
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Cheer (☞ﾟヮﾟ)☞ ☜(ﾟヮﾟ☜)</p>
:ET